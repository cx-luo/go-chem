// Package reaction_test provides tests for reaction saving functionality
// coding=utf-8
// @Project : go-chem
// @Time    : 2025/11/08
// @Author  : chengxiang.luo
// @Email   : chengxiang.luo@foxmail.com
// @File    : reaction_saver_test.go
// @Software: GoLand
package reaction_test

import (
	"os"
	"strings"
	"testing"
)

// Test ChemAxon CXSMILES format for reactions
func TestReactionToCXSmiles(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString(`<?xml version="1.0" encoding="windows-1252"?><cml xmlns="http://www.chemaxon.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.chemaxon.com/marvin/schema/mrvSchema_20_9_0.xsd" version="ChemAxon file format v20.9.0, generated by v20.8.0">
<MHead><MarvinGUI><mprop name="saveproperties" dataType="xsd:boolean" value="true"></mprop><mprop name="aminoAcidBondColoringEnabled" dataType="xsd:boolean" value="true"></mprop><mprop name="automaticReactionEnabled" dataType="xsd:boolean" value="true"></mprop><mprop name="setColoringEnabled" dataType="xsd:boolean" value="true"></mprop><mprop name="atomNumberingType" dataType="xsd:integer" value="0"></mprop><mprop name="fogFactor" dataType="xsd:integer" value="66"></mprop><mprop name="automaticFogEnabled" dataType="xsd:boolean" value="false"></mprop><mprop name="atomPropertiesVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="atomMappingVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="EZVisible" dataType="xsd:boolean" value="false"></mprop><mprop name="mpVisible" dataType="xsd:boolean" value="false"></mprop><mprop name="bondLength" dataType="xsd:double" value="28.0"></mprop><mprop name="bondLengthVisible" dataType="xsd:boolean" value="false"></mprop><mprop name="valenceErrorVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="valenceErrorVisibleInView" dataType="xsd:boolean" value="false"></mprop><mprop name="atomSymbolVisible3D" dataType="xsd:boolean" value="true"></mprop><mprop name="rgroupsVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="lonePairsAutoCalc" dataType="xsd:boolean" value="true"></mprop><mprop name="lonePairsAsLine" dataType="xsd:boolean" value="false"></mprop><mprop name="chargeWithCircle" dataType="xsd:boolean" value="false"></mprop><mprop name="molbg" value="#ffffff"></mprop><mprop name="chiralitySupport" dataType="xsd:integer" value="0"></mprop><mprop name="atomsize" dataType="xsd:double" value="0.35714285714"></mprop><mprop name="boldBondWidth" dataType="xsd:double" value="5.0"></mprop><mprop name="bondSpacing" dataType="xsd:double" value="0.180375"></mprop><mprop name="bondHashSpacing" dataType="xsd:double" value="0.15"></mprop><mprop name="wireThickness" dataType="xsd:double" value="0.066666"></mprop><mprop name="stickThickness" dataType="xsd:double" value="0.1"></mprop><mprop name="ballRadius" dataType="xsd:double" value="0.5"></mprop><mprop name="rendering" value="wireframe"></mprop><mprop name="downWedge" value="mdl"></mprop><mprop name="coordinateBondStyle" value="arrow"></mprop><mprop name="coordinateBondStyleAtMulticenter" value="hashed"></mprop><mprop name="anybond" value="auto"></mprop><mprop name="sketchAnyBond" value="auto"></mprop><mprop name="viewAnyBond" value="auto"></mprop><mprop name="atomFont" dataType="xsd:mfont" value="SansSerif-PLAIN-10"></mprop><mprop name="sketchImplicitH" value="heteroterm"></mprop><mprop name="lonePairsVisible" dataType="xsd:boolean" value="false"></mprop><mprop name="autoscale" dataType="xsd:boolean" value="false"></mprop><mprop name="absLabelVisible" dataType="xsd:boolean" value="false"></mprop><mprop name="colorScheme" value="cpk"></mprop><mprop name="viewCarbonVisibility" value="inChain"></mprop><mprop name="sketchCarbonVisibility" value="inChain"></mprop><mprop name="viewLigandOrderVisibility" value="showOnlyWithDefinition"></mprop><mprop name="sketchLigandOrderVisibility" value="showOnlyWithDefinition"></mprop><mprop name="rLogicVisible" value="off"></mprop><mprop name="peptideDisplayType" value="3-letter"></mprop><mprop name="zeroBasedAtomIndexing" dataType="xsd:boolean" value="false"></mprop><mprop name="valencePropertyVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="ligandErrorVisible" dataType="xsd:boolean" value="true"></mprop><mprop name="sketchArrowHeadLength" dataType="xsd:double" value="0.8"></mprop><mprop name="sketchArrowHeadWidth" dataType="xsd:double" value="0.5"></mprop><mprop name="sketchArrowTailLength" dataType="xsd:double" value="0.8"></mprop><mprop name="sketchArrowTailWidth" dataType="xsd:double" value="0.5"></mprop><mprop name="scale" dataType="xsd:double" value="18.0"></mprop></MarvinGUI></MHead>
<MDocument><MChemicalStruct><reaction><arrow type="DEFAULT" x1="-1.0912356798648588" y1="0.23466859238039472" x2="2.8693469280475767" y2="0.23466859238039472"></arrow><reactantList><molecule molID="m1"><atomArray atomID="a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11" elementType="C O C C O N C C C N C" x2="-20.7621 -22.0958 -22.0958 -23.4294 -24.7631 -23.4294 -24.5184 -23.4294 -24.5184 -22.3405 -22.3405" y2="-3.9434 -3.1734 -1.6334 -0.8634 -1.6334 0.6766 1.7655 2.8545 3.9434 3.9434 1.7655"></atomArray><bondArray><bond id="b1" atomRefs2="a1 a2" order="1"></bond><bond id="b2" atomRefs2="a2 a3" order="1"></bond><bond id="b3" atomRefs2="a3 a4" order="1"></bond><bond id="b4" atomRefs2="a4 a5" order="2"></bond><bond id="b5" atomRefs2="a4 a6" order="1"></bond><bond id="b6" atomRefs2="a6 a7" order="1"></bond><bond id="b7" atomRefs2="a6 a11" order="1"></bond><bond id="b8" atomRefs2="a7 a8" order="1"></bond><bond id="b9" atomRefs2="a8 a9" order="1"></bond><bond id="b10" atomRefs2="a8 a10" order="1"></bond><bond id="b11" atomRefs2="a8 a11" order="1"></bond></bondArray></molecule><molecule molID="m2"><atomArray atomID="a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14" elementType="C O C C C C Cl C C N C O C N" x2="-3.0800 -4.4137 -4.4137 -3.0800 -3.0800 -4.4137 -4.4137 -5.7474 -5.7474 -7.0810 -8.4147 -8.4147 -9.7484 -11.0821" y2="3.6365 2.8665 1.3265 0.5565 -0.9835 -1.7535 -3.2935 -0.9835 0.5565 1.3265 0.5565 -0.9835 1.3265 0.5565"></atomArray><bondArray><bond id="b1" atomRefs2="a1 a2" order="1"></bond><bond id="b2" atomRefs2="a2 a3" order="1"></bond><bond id="b3" atomRefs2="a3 a4" order="2"></bond><bond id="b4" atomRefs2="a3 a9" order="1"></bond><bond id="b5" atomRefs2="a4 a5" order="1"></bond><bond id="b6" atomRefs2="a5 a6" order="2"></bond><bond id="b7" atomRefs2="a6 a7" order="1"></bond><bond id="b8" atomRefs2="a6 a8" order="1"></bond><bond id="b9" atomRefs2="a8 a9" order="2"></bond><bond id="b10" atomRefs2="a9 a10" order="1"></bond><bond id="b11" atomRefs2="a10 a11" order="1"></bond><bond id="b12" atomRefs2="a11 a12" order="2"></bond><bond id="b13" atomRefs2="a11 a13" order="1"></bond><bond id="b14" atomRefs2="a13 a14" order="1"></bond></bondArray></molecule></reactantList><productList><molecule molID="m3"><atomArray atomID="a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29" elementType="O C O C F F F O C N C C C C O N C O C O C C C C C N C C C" lonePair="2 0 2 0 3 3 3 2 0 1 0 0 0 0 2 1 0 2 0 2 0 0 0 0 0 1 0 0 0" x2="5.0600 6.3937 7.7274 6.3937 6.3937 7.9337 4.8537 17.8230 18.2989 17.3937 15.8537 15.0837 13.5437 12.7737 11.2337 13.5437 15.0837 15.8537 18.2989 17.8230 19.7635 21.0972 22.4309 22.4309 23.8955 24.8007 23.8955 21.0972 19.7635" y2="-1.5288 -0.7588 -1.5288 0.7812 2.3212 0.7812 0.7812 -2.7105 -1.2459 -0.0000 -0.0000 -1.3337 -1.3337 -0.0000 -0.0000 1.3337 1.3337 2.6674 1.2459 2.7105 0.7700 1.5400 0.7700 -0.7700 -1.2459 -0.0000 1.2459 -1.5400 -0.7700"></atomArray><bondArray><bond id="b1" atomRefs2="a1 a2" order="1"></bond><bond id="b2" atomRefs2="a2 a3" order="2"></bond><bond id="b3" atomRefs2="a2 a4" order="1"></bond><bond id="b4" atomRefs2="a4 a5" order="1"></bond><bond id="b5" atomRefs2="a4 a6" order="1"></bond><bond id="b6" atomRefs2="a4 a7" order="1"></bond><bond id="b7" atomRefs2="a8 a9" order="2"></bond><bond id="b8" atomRefs2="a9 a10" order="1"></bond><bond id="b9" atomRefs2="a9 a29" order="1"></bond><bond id="b10" atomRefs2="a10 a11" order="1"></bond><bond id="b11" atomRefs2="a10 a19" order="1"></bond><bond id="b12" atomRefs2="a11 a12" order="1"></bond><bond id="b13" atomRefs2="a11 a17" order="1"></bond><bond id="b14" atomRefs2="a12 a13" order="1"></bond><bond id="b15" atomRefs2="a13 a14" order="1"></bond><bond id="b16" atomRefs2="a14 a15" order="2"></bond><bond id="b17" atomRefs2="a14 a16" order="1"></bond><bond id="b18" atomRefs2="a16 a17" order="1"></bond><bond id="b19" atomRefs2="a17 a18" order="2"></bond><bond id="b20" atomRefs2="a19 a20" order="2"></bond><bond id="b21" atomRefs2="a19 a21" order="1"></bond><bond id="b22" atomRefs2="a21 a22" order="2"></bond><bond id="b23" atomRefs2="a21 a29" order="1"></bond><bond id="b24" atomRefs2="a22 a23" order="1"></bond><bond id="b25" atomRefs2="a23 a24" order="2"></bond><bond id="b26" atomRefs2="a23 a27" order="1"></bond><bond id="b27" atomRefs2="a24 a25" order="1"></bond><bond id="b28" atomRefs2="a24 a28" order="1"></bond><bond id="b29" atomRefs2="a25 a26" order="1"></bond><bond id="b30" atomRefs2="a26 a27" order="1"></bond><bond id="b31" atomRefs2="a28 a29" order="2"></bond></bondArray></molecule></productList></reaction></MChemicalStruct><MReactionSign id="o2" fontScale="10.0" halign="CENTER" valign="CENTER" autoSize="false"><Field name="text"><![CDATA[{D font=SansSerif,size=18,bold}+]]></Field><MPoint x="-16.2221" y="0.9690"></MPoint><MPoint x="-15.6221" y="0.9690"></MPoint><MPoint x="-15.6221" y="-0.2960"></MPoint><MPoint x="-16.2221" y="-0.2960"></MPoint></MReactionSign></MDocument>
</cml>`)
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	cxsmiles, err := rxn.ToCXSmiles()
	if err != nil {
		t.Fatalf("Failed to convert to CXSmiles: %v", err)
	}

	if cxsmiles == "" {
		t.Error("CXSmiles is empty")
	}

	// Should contain reaction arrow >>
	if !strings.Contains(cxsmiles, ">>") {
		t.Error("CXSmiles doesn't contain reaction arrow >>")
	}

	t.Logf("CXSmiles: %s", cxsmiles)
}

// Test Canonical ChemAxon CXSMILES format for reactions
func TestReactionToCanonicalCXSmiles(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO.CC(=O)O>>CC(=O)OCC.O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	cxsmiles, err := rxn.ToCanonicalSmiles()
	if err != nil {
		t.Fatalf("Failed to convert to canonical SMILES: %v", err)
	}

	if cxsmiles == "" {
		t.Error("Canonical SMILES is empty")
	}

	if !strings.Contains(cxsmiles, ">>") {
		t.Error("Canonical SMILES doesn't contain reaction arrow >>")
	}

	t.Logf("Canonical SMILES: %s", cxsmiles)
}

// Test Daylight SMILES format for reactions
func TestReactionToDaylightSmiles(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("C=C.Br>>BrCC")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	smiles, err := rxn.ToDaylightSmiles()
	if err != nil {
		t.Fatalf("Failed to convert to Daylight SMILES: %v", err)
	}

	if smiles == "" {
		t.Error("Daylight SMILES is empty")
	}

	t.Logf("Daylight SMILES: %s", smiles)
}

// Test SMARTS conversion
func TestReactionToSmarts(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	smarts, err := rxn.ToSmarts()
	if err != nil {
		t.Fatalf("Failed to convert to SMARTS: %v", err)
	}

	if smarts == "" {
		t.Error("SMARTS is empty")
	}

	t.Logf("SMARTS: %s", smarts)
}

// Test CML file saving
func TestReactionSaveToCMLFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.cml"
	defer os.Remove(filename)

	err = rxn.SaveToCMLFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to CML file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("CML file is empty")
	}

	t.Logf("CML file size: %d bytes", info.Size())
}

// Test CDXML file saving
func TestReactionSaveToCDXMLFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.cdxml"
	defer os.Remove(filename)

	err = rxn.SaveToCDXMLFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to CDXML file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("CDXML file is empty")
	}

	t.Logf("CDXML file size: %d bytes", info.Size())
}

// Test CDX file saving
func TestReactionSaveToCDXFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.cdx"
	defer os.Remove(filename)

	err = rxn.SaveToCDXFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to CDX file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("CDX file is empty")
	}

	t.Logf("CDX file size: %d bytes", info.Size())
}

// Test JSON format conversion
func TestReactionToJSON(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	json, err := rxn.ToJSON()
	if err != nil {
		t.Fatalf("Failed to convert to JSON: %v", err)
	}

	if json == "" {
		t.Error("JSON is empty")
	}

	// JSON should contain typical JSON structure
	if !strings.Contains(json, "{") || !strings.Contains(json, "}") {
		t.Error("JSON doesn't contain valid JSON structure")
	}

	t.Logf("JSON length: %d bytes", len(json))
}

// Test JSON file saving
func TestReactionSaveToJSONFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.ket"
	defer os.Remove(filename)

	err = rxn.SaveToJSONFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to JSON file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("JSON file is empty")
	}

	t.Logf("JSON file size: %d bytes", info.Size())
}

// Test RDF format conversion
func TestReactionToRDF(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	rdf, err := rxn.ToRDF()
	if err != nil {
		t.Fatalf("Failed to convert to RDF: %v", err)
	}

	if rdf == "" {
		t.Error("RDF is empty")
	}

	t.Logf("RDF length: %d bytes", len(rdf))
}

// Test RDF file saving
func TestReactionSaveToRDFFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.rdf"
	defer os.Remove(filename)

	err = rxn.SaveToRDFFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to RDF file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("RDF file is empty")
	}

	t.Logf("RDF file size: %d bytes", info.Size())
}

// Test buffer conversion
func TestReactionToBuffer(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	buffer, err := rxn.ToBuffer()
	if err != nil {
		t.Fatalf("Failed to convert to buffer: %v", err)
	}

	if len(buffer) == 0 {
		t.Error("Buffer is empty")
	}

	// Buffer should contain RXN format data
	bufferStr := string(buffer)
	if !strings.Contains(bufferStr, "$RXN") && !strings.Contains(bufferStr, "V2000") {
		t.Logf("Warning: Buffer may not contain valid RXN format (first 100 chars): %s", bufferStr[:min(100, len(bufferStr))])
	}

	t.Logf("Buffer size: %d bytes", len(buffer))
}

// Test CDX Base64 conversion
func TestReactionToCDXBase64(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	cdxBase64, err := rxn.ToCDXBase64()
	if err != nil {
		t.Fatalf("Failed to convert to CDX Base64: %v", err)
	}

	if cdxBase64 == "" {
		t.Error("CDX Base64 is empty")
	}

	t.Logf("CDX Base64 length: %d bytes", len(cdxBase64))
}

// Test base64 string conversion
func TestReactionToBase64String(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	buffer, err := rxn.ToBuffer()
	if err != nil {
		t.Fatalf("Failed to convert to base64: %v", err)
	}

	if len(buffer) == 0 {
		t.Error("Base64 string is empty")
	}

	t.Logf("Base64 length: %d bytes", len(buffer))
}

// Test KET format conversion
func TestReactionToKet(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	ket, err := rxn.ToKet()
	if err != nil {
		t.Fatalf("Failed to convert to KET: %v", err)
	}

	if ket == "" {
		t.Error("KET is empty")
	}

	// KET should contain JSON structure
	if !strings.Contains(ket, "{") || !strings.Contains(ket, "}") {
		t.Error("KET doesn't contain valid JSON structure")
	}

	t.Logf("KET length: %d bytes", len(ket))
}

// Test KET file saving
func TestReactionSaveToKetFile(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	filename := "test_reaction.ket"
	defer os.Remove(filename)

	err = rxn.SaveToKetFile(filename)
	if err != nil {
		t.Fatalf("Failed to save to KET file: %v", err)
	}

	// Check if file exists and has content
	info, err := os.Stat(filename)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	if info.Size() == 0 {
		t.Error("KET file is empty")
	}

	t.Logf("KET file size: %d bytes", info.Size())
}

// Test format consistency with complex reaction
func TestReactionFormatConsistency(t *testing.T) {
	// Test with Fischer esterification
	testCases := []struct {
		name   string
		smiles string
	}{
		{"Simple oxidation", "CCO>>CC=O"},
		{"Addition", "C=C.Br>>BrCC"},
		{"Esterification", "CCO.CC(=O)O>>CC(=O)OCC.O"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			rxn, err := indigoInit.LoadReactionFromString(tc.smiles)
			if err != nil {
				t.Fatalf("Failed to load reaction %s: %v", tc.smiles, err)
			}
			defer rxn.Close()

			// Test all SMILES variants
			formats := map[string]func() (string, error){
				"SMILES":    rxn.ToSmiles,
				"Canonical": rxn.ToCanonicalSmiles,
				"CXSmiles":  rxn.ToCXSmiles,
				"Daylight":  rxn.ToDaylightSmiles,
				"SMARTS":    rxn.ToSmarts,
			}

			for name, fn := range formats {
				result, err := fn()
				if err != nil {
					t.Errorf("Failed to convert to %s: %v", name, err)
					continue
				}
				if result == "" {
					t.Errorf("%s is empty", name)
				}
				// All reaction formats should contain >>
				if !strings.Contains(result, ">>") {
					t.Errorf("%s doesn't contain reaction arrow: %s", name, result)
				}
			}
		})
	}
}

// Test all file formats
func TestReactionAllFileFormats(t *testing.T) {
	rxn, err := indigoInit.LoadReactionFromString("CCO>>CC=O")
	if err != nil {
		t.Fatalf("Failed to load reaction: %v", err)
	}
	defer rxn.Close()

	fileTests := []struct {
		name     string
		filename string
		saveFn   func(string) error
	}{
		{"RXN", "test.rxn", rxn.SaveToFile},
		{"JSON", "test.ket", rxn.SaveToJSONFile},
		{"CML", "test.cml", rxn.SaveToCMLFile},
		{"CDXML", "test.cdxml", rxn.SaveToCDXMLFile},
		{"CDX", "test.cdx", rxn.SaveToCDXFile},
		{"RDF", "test.rdf", rxn.SaveToRDFFile},
	}

	for _, tt := range fileTests {
		t.Run(tt.name, func(t *testing.T) {
			defer os.Remove(tt.filename)

			err := tt.saveFn(tt.filename)
			if err != nil {
				t.Errorf("Failed to save %s file: %v", tt.name, err)
				return
			}

			info, err := os.Stat(tt.filename)
			if err != nil {
				t.Errorf("Failed to stat %s file: %v", tt.name, err)
				return
			}

			if info.Size() == 0 {
				t.Errorf("%s file is empty", tt.name)
			}

			t.Logf("%s file size: %d bytes", tt.name, info.Size())
		})
	}
}

// Helper function
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
